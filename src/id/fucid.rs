use rand::thread_rng;
use rand::RngCore;
use std::cell::RefCell;

use super::Id;
use super::OwnedId;

pub struct FUCIDgen {
    salt: u128,
    counter: u128,
}

impl FUCIDgen {
    pub fn new() -> Self {
        Self {
            salt: {
                let mut rng = thread_rng();
                let mut rand_bytes = [0; 16];
                rng.fill_bytes(&mut rand_bytes[..]);

                u128::from_be_bytes(rand_bytes)
            },
            counter: 0,
        }
    }

    pub fn next(&mut self) -> OwnedId {
        let next_id = self.counter ^ self.salt;
        self.counter += 1;
        let id = next_id.to_be_bytes();
        OwnedId::force(
            Id::new(id).expect("The probability for counter ^ salt = 0 should be neglegible."),
        )
    }
}

thread_local!(static GEN_STATE: RefCell<FUCIDgen> = RefCell::new(FUCIDgen::new()));

/// # Fast Unsafe Compressible IDs (FUCIDs)
/// Are generated by XORing a 128bit `salt` with a 128bit incrementing integer.
/// The salt is unique for each source generating fucids (i.e. each thread),
/// and initialized with 128bits of cryptographic randomness.
/// This creates a pseudo-random exhaustive walk through the 128bit space,
/// while maintaining high per-source locality.
/// It might seem counter intuitive that an identifier with low entropy
/// can still be used in a distributed setting. Note however fucids only have
/// low entropy between each other when they are from the same source (thread).
/// This makes them succeptible to collisions due to hardware errors (bit-flips),
/// but they still retain high global uniqueness without coordination.
/// E.g. in a scenario where every source only generates a single fucid the
/// scheme degenerates to the rngid scheme.
pub fn fucid() -> OwnedId {
    GEN_STATE.with_borrow_mut(|gen| gen.next())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn unique() {
        assert!(fucid() != fucid());
    }
}
