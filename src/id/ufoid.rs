use rand::{thread_rng, RngCore};
use std::time::{SystemTime, UNIX_EPOCH};

use super::{Id, OwnedId};

/// # Universal Forgettable Ordered IDs (UFOIDs)
/// Are generated by concatenaing a rolling 32bit millisecond timestamp with
/// 96bits of cryptographic randomness. This provides high locality for ufoids
/// minted in close temporal proximity, and it provides fast and simple
/// identification of "old" ids in contexts where high data generation requires
/// regular garbage collection of stale information (e.g. robotics).
/// A range of 2^32 milliseconds corresponds to a rolling window of ~50 days,
/// which should be wide enough for most high-volume use cases, while still
/// providing sufficient bits of high-quality entropy. Having a practically
/// relevant rollover rate, also ensures that this edge case is accounted for
/// and tested, compared to schemes which place the burden of dealing with
/// overflows on future generations.
pub fn ufoid() -> OwnedId {
    let mut rng = thread_rng();
    let now_in_sys = SystemTime::now();
    let now_since_epoch = now_in_sys
        .duration_since(UNIX_EPOCH)
        .expect("time went backwards");
    let now_in_ms = now_since_epoch.as_millis();

    let mut id = [0; 16];
    id[0..4].copy_from_slice(&(now_in_ms as u32).to_be_bytes());
    rng.fill_bytes(&mut id[4..16]);

    OwnedId::force(Id::new(id).expect("The probability time and rng = 0 should be neglegible."))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn unique() {
        assert!(ufoid() != ufoid());
    }
}
