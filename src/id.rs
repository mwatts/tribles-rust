//! # Identifiers for Distributed Systems
//! We found it useful to categorize identifiers along two axes:
//! 
//! |                | **Abstract**        | **Semantic**        |
//! |----------------|---------------------|---------------------|
//! | **Intrinsic**  | Hash, Signature     | embeddings          |
//! | **Extrinsic**  | UUID, UFOID, FUCID  | names, DOI, URL     |
//! 
//! ## Abstract vs. Semantic Identifiers
//! 
//! - **Semantic Identifiers (e.g., human-readable names, URLs, attribute names, head labels)**  
//!   These identifiers act as a bridge between human users and the system, offering clarity
//!   and familiarity. However, they do not work well as an identity; their purpose is to aid
//!   interpretation rather than define persistence.
//!   They have a high chance of collisions without some form of centralized authority or coordination.
//!
//! - **Abstract Identifiers (e.g., UUIDs, UFOIDs, FUCIDs, hashes, signatures)**  
//!   These identifiers provide abstract identity without imposing any semantic meaning or cultural connotations.
//!   They can be generated cheaply and without coordination, relying on high entropy to make collisions
//!   practically impossible, uniquely, globally, and persistently addressing an entity, regardless of its content or context.
//! 
//! Abstract identifiers, when used to reference entities in a system, provide a stable and unique identity that is
//! independent of the content or context of the entity. They are particularly useful in distributed systems, where
//! they can be used to address entities across different nodes without requiring a central authority.
//! 
//! To avoid ambiguities and conflicts, semantic identifiers should always be explicitly
//! scoped to a context, such as a namespace or system environment. This ensures that the
//! same name can coexist in different contexts without collision or confusion.
//! This scoping also addresses social challenges inherent in semantic identifiers:
//! different users may prefer different names for the same entity.
//! By allowing local names to reference persistent identifiers (extrinsic or intrinsic),
//! each user can adopt their preferred naming conventions while maintaining
//! a shared understanding of the underlying identity.
//! 
//! ## Intrinsic vs. Extrinsic Identifiers
//! 
//! - **Intrinsic Identifiers (e.g., hashes, signatures)**  
//!   These identifiers provide intrinsic identity by acting as unique fingerprints of the exact content they represent.
//!   Unlike abstract identifiers, intrinsic identifiers are directly tied to the data itself, ensuring immutability
//!   and self-validation.
//!
//!   Intrinsic identifiers are generated by applying cryptographic functions to the content. Their entropy requirements
//!   are higher than those of abstract identifiers, as they must not only prevent accidental collisions but also
//!   withstand adversarial scenarios, such as deliberate attempts to forge data.
//! 
//! - **Extrinsic Identifiers (e.g., human-readable names, URLs, DOIs, UUIDs, UFOIDs, FUCIDs)**
//!   These identifiers provide identity that is not tied to the content itself,
//!   but only by association. They are used to reference entities in a system, but do not
//!   provide any guarantees about the content or the entity itself.
//!   Allowing for continuity even as that entity may change or evolve.
//!
//! Extrinsic identifiers and intrinsic identifiers represent different kinds of metaphysical identity.  
//! For example, in the ship of Theseus thought experiment, both the original ship and the reconstructed ship  
//! would share the same extrinsic identity but have different intrinsic identities.
//! 
//! ## Embeddings as Semantic Intrinsic Identifiers
//! Note that embeddings are the somewhat curious case of semantic intrinsic identifiers.
//! They are intrinsic in that they are tied to the content they represent, but they are also semantic in that they
//! carry meaning about the content. Embeddings are used to represent the content of an entity in a way that can be
//! compared to other entities, such as for similarity search or classification.
//! This makes them especially interesting for search and retrieval systems, where they can be used to find similar
//! entities based on a reference entity. But less useful for identity, as they are not necessarily unique.
//! 
//! ## High-Entropy Identifiers
//!
//! For a truly distributed system, the creation of identifiers must avoid the bottlenecks and overhead associated
//! with a central coordinating authority. At the same time, we must ensure that these identifiers are unique.  
//!
//! To guarantee uniqueness, we use identifiers containing a large amount of entropy, making collisions
//! statistically irrelevant. However, the entropy requirements differ based on the type of identifier:
//! - **Extrinsic identifiers** need enough entropy to prevent accidental collisions in normal operation.
//! - **Intrinsic identifiers** must also resist adversarial forging attempts, requiring significantly higher entropy.  
//!
//! From an information-theoretic perspective, the length of an identifier determines the maximum amount of
//! entropy it can encode. For example, a 128-bit identifier can represent \( 2^{128} \) unique values, which is
//! sufficient to make collisions statistically negligible even for large-scale systems.  
//!
//! For intrinsic identifiers, 256 bits is widely considered sufficient when modern cryptographic hash functions
//! (e.g., SHA-256) are used. These hash functions provide strong guarantees of collision resistance, preimage
//! resistance, and second-preimage resistance. Even in the event of weaknesses being discovered in a specific
//! algorithm, it is more practical to adopt a new hash function than to increase the bit size of identifiers.  
//!
//! Additionally, future advances such as quantum computing are unlikely to undermine this length. Grover's algorithm
//! would halve the effective security of a 256-bit hash, reducing it to \( 2^{128} \) operations—still infeasible with
//! current or theoretical technology. As a result, 256 bits remains a future-proof choice for intrinsic identifiers.  
//!
//! Such 256-bit intrinsic identifiers are represented by the types
//! [`tribles::value::schemas::hash::Hash`](crate::value::schemas::hash::Hash) and
//! [`tribles::value::schemas::hash::Handle`](crate::value::schemas::hash::Handle).  
//!
//! Additionally, we define three types of high-entropy abstract identifiers to address different requirements:  
//! **RNGID, UFOID, and FUCID.** Each balances trade-offs between entropy, locality, compression, and
//! predictability, as summarized below.
//!
//! ## Comparison of Identifier Types
//!
//! |                | [RNGID](rngid::rngid) | [UFOID](ufoid::ufoid) | [FUCID](fucid::fucid) |
//! |----------------|-----------------------|-----------------------|------------------------|
//! | Entropy        | High                  | High                  | Low                   |
//! | Locality       | None                  | High                  | High                  |
//! | Compression    | None                  | Low                   | High                  |
//! | Predictability | None                  | Low                   | Mid                   |
//!
//! # Example: Scientific Publishing
//!
//! Consider the case of published scientific papers. Each artifact, such as a `.html` or `.pdf` file,
//! should be identified by its abstract intrinsic identifier, typically a cryptographic hash of its content.
//! This ensures that any two entities referencing the same hash are referring to the exact same version
//! of the artifact, providing immutability and validation.  
//!
//! Across different versions of the same paper, an abstract extrinsic identifier can be used to tie these
//! artifacts together as part of one logical entity. The identifier provides continuity,
//! regardless of changes to the paper’s content over time.  
//!
//! Semantic (human-readable) identifiers, such as abbreviations in citations or bibliographies, are scoped to
//! individual papers and provide context-specific usability for readers. These names do not convey
//! identity but serve as a way for humans to reference the persistent abstract identifiers that underlie the system.
//!
//! Sadly the identifiers used in practice, such as DOIs, fail to align with these principles and strengths.
//! They attempt to provide global extrinsic semantic identifiers for scientific papers,
//! an ultimately flawed approach. They lack the associated guarantees of intrinsic identifiers
//! and bring all the challenges of semantic identifiers. With their scope defined too broadly,
//! and their authority centralized, they fail to live up to the potential of distributed systems.
//! 
//! # ID Ownership
//!
//! In distributed systems, consistency requires monotonicity due to the CALM principle.
//! However, this is not necessary for single writer systems. By assigning each ID an owner,
//! we ensure that only the current owner can write new information about an entity associated
//! with that ID. This allows for fine-grained synchronization and concurrency control.
//!
//! To create a transaction, you can uniquely own all entities involved and write new data for them
//! simultaneously. Since there can only be one owner for each ID at any given time, you can be
//! confident that no other information has been written about the entities in question.
//!
//! By default, all minted `ExclusiveId`s are associated with the thread they are dropped from.
//! These IDs can be found in queries via the `local_ids` function.
//!
//! ## Ownership and Eventual Consistency
//!
//! While a simple grow set like the history stored in a [Head](crate::remote::Head)
//! already constitutes a conflict-free replicated data type (CRDT), it is also limited in expressiveness.
//! To provide richer semantics while guaranteeing conflict-free mergeability we allow only
//! "owned" IDs to be used in the `entity` position of newly generated triples.
//! As owned IDs are [Send] but not [Sync] owning a
//! set of them essentially constitutes a single writer transaction domain,
//! allowing for some non-monotonic operations like `if-does-not-exist`, over
//! the set of contained entities. Note that this does not make operations that
//! would break CALM (consistency as logical monotonicity) safe, e.g. `delete`.
//!

pub mod fucid;
pub mod rngid;
pub mod ufoid;

use std::{
    borrow::Borrow,
    cell::RefCell,
    convert::TryInto,
    fmt::{Display, LowerHex, UpperHex},
    hash::Hash,
    marker::PhantomData,
    mem,
    num::NonZero,
    ops::Deref,
};

pub use fucid::{fucid, FUCIDsource};
pub use rngid::rngid;
pub use ufoid::ufoid;

use crate::{
    patch::{Entry, IdentityOrder, SingleSegmentation, PATCH},
    prelude::valueschemas::GenId,
    query::{Constraint, ContainsConstraint, Variable},
    value::{RawValue, VALUE_LEN},
};

thread_local!(static OWNED_IDS: IdOwner = IdOwner::new());

/// The length of a 128bit abstract identifier in bytes.
pub const ID_LEN: usize = 16;

/// Represents a 16 byte abstract identifier.
pub type RawId = [u8; ID_LEN];

/// Converts a 16 byte [RawId] reference into an 32 byte [RawValue].
pub(crate) fn id_into_value(id: &RawId) -> RawValue {
    let mut data = [0; VALUE_LEN];
    data[16..32].copy_from_slice(id);
    data
}

/// Converts a 32 byte [RawValue] reference into an 16 byte [RawId].
/// Returns `None` if the value is not in the canonical ID format,
/// i.e. the first 16 bytes are all zero.
pub(crate) fn id_from_value(id: &RawValue) -> Option<RawId> {
    if id[0..16] != [0; 16] {
        return None;
    }
    let id = id[16..32].try_into().unwrap();
    Some(id)
}

/// Represents a unique abstract 128 bit identifier.
/// As we do not allow for all zero `nil` IDs,
/// `Option<Id>` benefits from Option nieche optimizations.
///
/// Note that it has an alignment of 1, and can be referenced as a `[u8; 16]` [RawId].
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(C, packed(1))]
pub struct Id {
    inner: NonZero<u128>,
}

impl Id {
    /// Creates a new `Id` from a [RawId] 16 byte array.
    pub const fn new(id: RawId) -> Option<Self> {
        unsafe { std::mem::transmute(id) }
    }

    /// Transmutes a reference to a [RawId] into a reference to an `Id`.
    /// Returns `None` if the referenced RawId is nil (all zero).
    pub fn transmute_raw(id: &RawId) -> Option<&Self> {
        if *id == [0; 16] {
            None
        } else {
            Some(unsafe { std::mem::transmute(id) })
        }
    }

    /// Takes ownership of this Id from the current write context (i.e. thread).
    /// Returns `None` if this Id was not found, because it is not associated with this
    /// write context, or because it is currently aquired.
    pub fn aquire(&self) -> Option<ExclusiveId> {
        OWNED_IDS.with(|owner| owner.take(self))
    }
}

impl PartialOrd for Id {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        let s: &RawId = &self;
        let o: &RawId = &other;
        PartialOrd::partial_cmp(s, o)
    }
}

impl Ord for Id {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        let s: &RawId = &self;
        let o: &RawId = &other;
        Ord::cmp(s, o)
    }
}

impl Hash for Id {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        let s: &RawId = &self;
        Hash::hash(s, state);
    }
}

impl Deref for Id {
    type Target = RawId;

    fn deref(&self) -> &Self::Target {
        unsafe { std::mem::transmute(self) }
    }
}

impl Borrow<RawId> for Id {
    fn borrow(&self) -> &RawId {
        self
    }
}

impl AsRef<RawId> for Id {
    fn as_ref(&self) -> &RawId {
        self
    }
}

impl AsRef<[u8]> for Id {
    fn as_ref(&self) -> &[u8] {
        &self[..]
    }
}

impl From<Id> for RawId {
    fn from(id: Id) -> Self {
        *id
    }
}

impl From<Id> for RawValue {
    fn from(id: Id) -> Self {
        id.into()
    }
}

impl Display for Id {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Id({self:X})")
    }
}

impl LowerHex for Id {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for byte in &self[..] {
            write!(f, "{byte:02x}")?;
        }
        Ok(())
    }
}

impl UpperHex for Id {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for byte in &self[..] {
            write!(f, "{byte:02X}")?;
        }
        Ok(())
    }
}

/// Creates an `Id` from a hex string literal.
///
/// # Example
/// ```
/// use tribles::id::id_hex;
/// let id = id_hex!("7D06820D69947D76E7177E5DEA4EA773");
/// ```
#[macro_export]
macro_rules! id_hex {
    ( $data:expr ) => {
        $crate::id::Id::new(hex_literal::hex!($data)).unwrap()
    };
}

pub use id_hex;

/// Represents an ID that can only be used by a single writer at a time.
///
/// `ExclusiveId`s are associated with one owning context (typically a thread) at a time.
/// Because they are `Send` and `!Sync`, they can be passed between contexts, but not used concurrently.
/// This makes use of Rust's borrow checker to enforce a weaker form of software transactional memory (STM) without rollbacks - as these are not an issue with the heavy use of copy-on-write data structures.
///
/// They are automatically associated with the thread they are dropped from, which can be used in queries via the [local_ids] constraint.
/// You can also make use of explicit [IdOwner] containers to store them when not actively used in a transaction.
///
/// Most methods defined on [ExclusiveId] are low-level primitives meant to be used for the implementation of new ownership management strategies,
/// such as a transactional database that tracks checked out IDs for ownership, or distributed ledgers like blockchains.
///
#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
#[repr(transparent)]
pub struct ExclusiveId {
    pub id: Id,
    // Make sure that the type can't be syntactically initialized.
    // Also make sure that we don't get auto impl of Send and Sync
    _private: PhantomData<*const ()>,
}

unsafe impl Send for ExclusiveId {}

impl ExclusiveId {
    /// Forces a regular (read-only) `Id` to become a writable `ExclusiveId`.
    ///
    /// This is a low-level primitive that is meant to be used for the implementation of new ownership management strategies,
    /// such as a transactional database that tracks checked out IDs for ownership, or distributed ledgers like blockchains.
    ///
    /// This should be done with care, as it allows scenarios where multiple writers can create conflicting information for the same ID.
    /// Similar caution should be applied when using the `transmute_force` and `forget` methods.
    ///
    /// # Arguments
    ///
    /// * `id` - The `Id` to be forced into an `ExclusiveId`.
    pub fn force(id: Id) -> Self {
        Self {
            id,
            _private: PhantomData,
        }
    }

    /// Safely transmutes a reference to an `Id` into a reference to an `ExclusiveId`.
    ///
    /// Similar caution should be applied when using the `force` method.
    ///
    /// # Arguments
    ///
    /// * `id` - A reference to the `Id` to be transmuted.
    pub fn transmute_force<'a>(id: &'a Id) -> &'a Self {
        unsafe { std::mem::transmute(id) }
    }

    /// Releases the `ExclusiveId`, returning the underlying `Id`.
    ///
    /// # Returns
    ///
    /// The underlying `Id`.
    pub fn release(self) -> Id {
        let id = self.id;
        mem::drop(self);
        id
    }

    /// Forgets the `ExclusiveId`, leaking ownership of the underlying `Id`, while returning it.
    ///
    /// This is not as potentially problematic as [force](ExclusiveId::force), because it prevents further writes with the `ExclusiveId`, thus avoiding potential conflicts.
    ///
    /// # Returns
    ///
    /// The underlying `Id`.
    pub fn forget(self) -> Id {
        let id = self.id;
        mem::forget(self);
        id
    }
}

impl Drop for ExclusiveId {
    fn drop(&mut self) {
        OWNED_IDS.with(|ids| {
            ids.force_insert(self);
        });
    }
}

impl Deref for ExclusiveId {
    type Target = Id;

    fn deref(&self) -> &Self::Target {
        &self.id
    }
}

impl Borrow<RawId> for ExclusiveId {
    fn borrow(&self) -> &RawId {
        self
    }
}

impl Borrow<Id> for ExclusiveId {
    fn borrow(&self) -> &Id {
        self
    }
}

impl AsRef<Id> for ExclusiveId {
    fn as_ref(&self) -> &Id {
        self
    }
}

impl AsRef<RawId> for ExclusiveId {
    fn as_ref(&self) -> &RawId {
        self
    }
}

impl AsRef<[u8]> for ExclusiveId {
    fn as_ref(&self) -> &[u8] {
        &self[..]
    }
}

impl Display for ExclusiveId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let id: &Id = self;
        write!(f, "ExclusiveId({id:X})")
    }
}

/// A constraint that checks if a variable is an `ExclusiveId` associated with the current write context (i.e. thread).
pub fn local_ids(v: Variable<GenId>) -> impl Constraint<'static> {
    OWNED_IDS.with(|owner| owner.has(v))
}

/// A container for [ExclusiveId]s, allowing for explicit ownership management.
/// There is an implicit `IdOwner` for each thread, to which `ExclusiveId`s are associated when they are dropped,
/// and which can be queried via the [local_ids] constraint.
///
/// # Example
///
/// ```
/// use tribles::id::{IdOwner, ExclusiveId, fucid};
/// let mut owner = IdOwner::new();
/// let exclusive_id = fucid();
/// let id = owner.insert(exclusive_id);
///
/// assert!(owner.owns(&id));
/// assert_eq!(owner.take(&id), Some(ExclusiveId::force(id)));
/// assert!(!owner.owns(&id));
/// ```
///
pub struct IdOwner {
    owned_ids: RefCell<PATCH<ID_LEN, IdentityOrder, SingleSegmentation>>,
}

/// An `ExclusiveId` that is associated with an `IdOwner`.
/// It is automatically returned to the `IdOwner` when dropped.
pub struct OwnedId<'a> {
    pub id: Id,
    owner: &'a IdOwner,
}

impl IdOwner {
    /// Creates a new `IdOwner`.
    ///
    /// This is typically not necessary, as each thread has an implicit `IdOwner` associated with it.
    ///
    /// # Returns
    ///
    /// A new `IdOwner`.
    pub fn new() -> Self {
        Self {
            owned_ids: RefCell::new(PATCH::new()),
        }
    }

    /// Inserts an `ExclusiveId` into the `IdOwner`, returning the underlying `Id`.
    ///
    /// # Arguments
    ///
    /// * `id` - The `ExclusiveId` to be inserted.
    ///
    /// # Returns
    ///
    /// The underlying `Id`.
    pub fn insert(&mut self, id: ExclusiveId) -> Id {
        self.force_insert(&id);
        id.forget()
    }

    /// Defers inserting an `ExclusiveId` into the `IdOwner`, returning an `OwnedId`.
    /// The `OwnedId` will return the `ExclusiveId` to the `IdOwner` when dropped.
    /// This is useful if you generated an `ExclusiveId` that you want to use temporarily,
    /// but want to make sure it is returned to the `IdOwner` when you are done.
    /// 
    /// # Arguments
    /// 
    /// * `id` - The `ExclusiveId` to be inserted.
    /// 
    /// # Returns
    /// 
    /// An `OwnedId` that will return the `ExclusiveId` to the `IdOwner` when dropped.
    /// 
    /// # Example
    /// 
    /// ```
    /// use tribles::prelude::*;
    /// use valueschemas::ShortString;
    /// use tribles::id_hex;
    /// 
    /// let mut owner = IdOwner::new();
    /// let owned_id = owner.defer_insert(fucid());
    /// let trible = Trible::new(&owned_id, &id_hex!("7830D7B3C2DCD44EB3FA68C93D06B973"), &ShortString::value_from("Hello, World!"));
    /// ```
    pub fn defer_insert(&self, id: ExclusiveId) -> OwnedId {
        OwnedId {
            id: id.forget(),
            owner: self,
        }
    }

    /// Forces an `Id` into the `IdOwner` as an `ExclusiveId`.
    ///
    /// # Arguments
    ///
    /// * `id` - The `Id` to be forced into an `ExclusiveId`.
    pub fn force_insert(&self, id: &Id) {
        let entry = Entry::new(&id);
        self.owned_ids.borrow_mut().insert(&entry);
    }

    /// Takes an `Id` from the `IdOwner`, returning it as an `ExclusiveId`.
    ///
    /// # Arguments
    ///
    /// * `id` - The `Id` to be taken.
    ///
    /// # Returns
    ///
    /// An `ExclusiveId` if the `Id` was found, otherwise `None`.
    pub fn take(&self, id: &Id) -> Option<ExclusiveId> {
        if self.owned_ids.borrow().has_prefix(id) {
            self.owned_ids.borrow_mut().remove(id);
            Some(ExclusiveId::force(*id))
        } else {
            None
        }
    }

    /// Get an `OwnedId` from the `IdOwner`.
    /// The `OwnedId` will return the `ExclusiveId` to the `IdOwner` when dropped.
    /// This is useful for temporary exclusive access to an `Id`.
    /// If you want to keep the `Id` for longer, you can use the `take` method,
    /// but you will have to manually return it to the `IdOwner` when you are done.
    /// 
    /// # Arguments
    /// 
    /// * `id` - The `Id` to be taken.
    /// 
    /// # Returns
    /// 
    /// An `OwnedId` if the `Id` was found, otherwise `None`.
    /// 
    /// # Example
    /// 
    /// ```
    /// use tribles::id::{IdOwner, ExclusiveId, fucid};
    /// let mut owner = IdOwner::new();
    /// let exclusive_id = fucid();
    /// let id = owner.insert(exclusive_id);
    ///  {
    ///     let mut owned_id = owner.borrow(&id).unwrap();
    /// 
    ///     assert_eq!(owned_id.id, id);
    ///     assert!(!owner.owns(&id));
    ///  }
    /// assert!(owner.owns(&id));
    /// ```
    pub fn borrow<'a>(&'a self, id: &Id) -> Option<OwnedId<'a>> {
        self.take(id).map(move |id| {
            OwnedId { id: id.forget(), owner: self }
        })
    }

    /// Checks if the `IdOwner` owns an `Id`.
    ///
    /// # Arguments
    ///
    /// * `id` - The `Id` to be checked.
    ///
    /// # Returns
    ///
    /// `true` if the `Id` is owned by the `IdOwner`, otherwise `false`.
    pub fn owns(&self, id: &Id) -> bool {
        self.owned_ids.borrow().has_prefix(id)
    }
}

impl Deref for OwnedId<'_> {
    type Target = ExclusiveId;

    fn deref(&self) -> &Self::Target {
        ExclusiveId::transmute_force(&self.id)
    }
}

impl Borrow<RawId> for OwnedId<'_> {
    fn borrow(&self) -> &RawId {
        self
    }
}

impl Borrow<Id> for OwnedId<'_> {
    fn borrow(&self) -> &Id {
        self
    }
}

impl Borrow<ExclusiveId> for OwnedId<'_> {
    fn borrow(&self) -> &ExclusiveId {
        self
    }
}

impl AsRef<ExclusiveId> for OwnedId<'_> {
    fn as_ref(&self) -> &ExclusiveId {
        self
    }
}

impl AsRef<Id> for OwnedId<'_> {
    fn as_ref(&self) -> &Id {
        self
    }
}

impl AsRef<RawId> for OwnedId<'_> {
    fn as_ref(&self) -> &RawId {
        self
    }
}

impl AsRef<[u8]> for OwnedId<'_> {
    fn as_ref(&self) -> &[u8] {
        &self[..]
    }
}

impl Display for OwnedId<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let id: &Id = self;
        write!(f, "OwnedId({id:X})")
    }
}

impl<'a> Drop for OwnedId<'a> {
    fn drop(&mut self) {
        self.owner.force_insert(&(self.id));
    }
}

impl ContainsConstraint<'static, GenId> for &IdOwner {
    type Constraint = <PATCH<ID_LEN, IdentityOrder, SingleSegmentation> as ContainsConstraint<
        'static,
        GenId,
    >>::Constraint;

    fn has(self, v: Variable<GenId>) -> Self::Constraint {
        self.owned_ids.borrow().clone().has(v)
    }
}

#[cfg(test)]
mod tests {
    use crate::examples::literature;
    use crate::id::ExclusiveId;
    use crate::prelude::*;

    #[test]
    fn id_formatting() {
        let id: Id = id_hex!("7D06820D69947D76E7177E5DEA4EA773");
        assert_eq!(format!("{id:x}"), "7d06820d69947d76e7177e5dea4ea773");
        assert_eq!(format!("{id:X}"), "7D06820D69947D76E7177E5DEA4EA773");
    }

    #[test]
    fn ns_local_ids() {
        let mut kb = TribleSet::new();

        {
            let isaac = ufoid();
            let jules = ufoid();
            kb += literature::entity!(&jules, {
                firstname: "Jules",
                lastname: "Verne"
            });
            kb += literature::entity!(&isaac, {
                firstname: "Isaac",
                lastname: "Asimov"
            });
        }

        let mut r: Vec<_> = find!(
            (author: ExclusiveId, name: String),
            and!(
                local_ids(author),
                literature::pattern!(&kb, [
                    {author @
                        firstname: name
                    }])
            )
        )
        .map(|(_, n)| n)
        .collect();
        r.sort();

        assert_eq!(vec!["Isaac", "Jules"], r);
    }
}
